---
title: "Sheet Three"
format: html
filters:
  - pyodide
---

NUMA01: Computational Programming with Python  
Malin Christersson, Robert Kl√∂fkorn  

The purpose of this training assignment is to repeat list comprehensions, practice slicing, work more with functions, and investigate sets in Python.  
You should not run the code before you have written down what it will do when executed.  
This assignment has 8 tasks.

## Warming-up Exercises

### Task 1

Assume we have stored the following values in a list:

```{pyodide-python}
#| read-only: false
L = [0, 1, 2, 1, 0, -1, -2, -1, 0]

# TODO:
# Predict what each line prints before running the cell.
print("L[0] =", L[0])
print("L[-1] =", L[-1])
print("L[:-1] =", L[:-1])
print("L + L[1:-1] + L =", L + L[1:-1] + L)

L_copy = L.copy()
L_copy[2:2] = [-3]
print("After inserting -3 at position 2:", L_copy)

L_copy = L.copy()
L_copy[3:4] = []
print("After deleting element at index 3:", L_copy)

L_copy = L.copy()
L_copy[2:5] = [-5]
print("After replacing indices 2:5 with -5:", L_copy)
```

### Task 2

What parts of the following code generate an error, and why?

```{pyodide-python}
#| read-only: false
d = dict()
print("Accessing missing key:", d["nokey"])

d["key"] = 3
print("Existing key:", d["key"])

del d["key"]
print("After deletion:", d["key"])

d[(1, 2)] = "tuple"
d[[1, 2]] = "list"
```

---

## Programming Exercises

### Task 3

Transition to the programming exercises below.

### Task 4

Let a distance table between some villages be given by:

$$
\begin{bmatrix}
0 & 20 & 30 & 40\\
20 & 0 & 50 & 60\\
30 & 50 & 0 & 70\\
40 & 60 & 70 & 0
\end{bmatrix}
$$

1. Construct a list (of lists) that contains this data. Call this list `distance`.  
2. Construct from this list a list `reddistance` which contains only the relevant data in the following form:

$$
\begin{bmatrix}
20\\
30 & 50\\
40 & 60 & 70
\end{bmatrix}
$$

Use slicing for this task. Solve it two ways: (1) with `for`-loops and (2) using only list comprehension and slicing.

```{pyodide-python}
#| read-only: false
# Build the full distance table.
distance = [
    [0, 20, 30, 40],
    [20, 0, 50, 60],
    [30, 50, 0, 70],
    [40, 60, 70, 0],
]

# TODO:
# 1) Create reddistance using for-loops and slicing.
reddistance_loops = []

# 2) Create reddistance using only list comprehension and slicing.
reddistance_comp = []

print("distance:", distance)
print("reddistance_loops:", reddistance_loops)
print("reddistance_comp:", reddistance_comp)
```

### Task 5

Let $A$ and $B$ be sets. The set $(A \setminus B) \cup (B \setminus A)$ is called the symmetric difference of the two sets.

Write a function that performs this operation. Compare your results to `A.symmetric_difference(B)`.

```{pyodide-python}
#| read-only: false
def symmetric_difference(A, B):
    """Return the symmetric difference of A and B without using the built-in method."""
    # TODO: replace with your own implementation.
    pass


A = {1, 2, 3, 4}
B = {3, 4, 5}

print("Custom symmetric difference:", symmetric_difference(A, B))
print("Built-in symmetric difference:", A.symmetric_difference(B))
```

### Task 6

Study other operations on sets. You find a complete list by using tab-completion in Spyder/IPython after typing `A.` where `A` is a previously defined set in Python.

In particular, study the methods `update` and `intersection_update`. Explain the difference between the commands `intersection` and `intersection_update`.

```{pyodide-python}
#| read-only: false
A = {1, 2, 3}
B = {3, 4, 5}

# TODO:
# Experiment with update, intersection, and intersection_update.
print("A before update:", A)
A.update(B)
print("A after update:", A)

A = {1, 2, 3}
print("A intersection B (new set):", A.intersection(B))
print("A after intersection (unchanged):", A)

A.intersection_update(B)
print("A after intersection_update (modified in place):", A)
```

### Task 7

Test in Python (with a couple of examples) the statement that the empty set is a subset of any set.

```{pyodide-python}
#| read-only: false
empty = set()

sets_to_test = [
    set(),
    {1},
    {1, 2, 3},
    {"a", "b"},
]

for idx, current in enumerate(sets_to_test, start=1):
    result = empty.issubset(current)
    print(f"Test {idx}: empty set subset of {current}? {result}")
```

### Task 8

**Bisection Method.** A continuous function that changes sign in an interval $[a, b]$ has at least one root there. Such a root can be found by the bisection method.  
Starting from $[a, b]$, investigate the sign change in the subintervals $[a, \tfrac{a+b}{2}]$ and $[\tfrac{a+b}{2}, b]$. If the sign changes in the first subinterval, redefine $b := \tfrac{a+b}{2}$; otherwise set $a := \tfrac{a+b}{2}$. Repeat until $b - a$ is less than a given tolerance. Note that a sign change is characterized by $f(a) f(b) < 0$.

Implement this algorithm. It needs the initial interval $[a, b]$ and the tolerance. Test the method with the function $\arctan(x)$ and with the polynomial $f(x) = 3x^2 - 5$ in the interval $[-0.5, 0.6]$ and alternatively in $[-1.5, -0.4]$.

```{pyodide-python}
#| read-only: false
import math

def bisection(f, a, b, tol=1e-6, max_iter=200):
    """Simple bisection method for a sign-changing interval [a, b]."""
    fa = f(a)
    fb = f(b)
    if fa * fb > 0:
        raise ValueError("f(a) and f(b) must have opposite signs.")

    for _ in range(max_iter):
        mid = 0.5 * (a + b)
        fm = f(mid)
        if abs(b - a) < tol:
            return mid
        if fa * fm <= 0:
            b, fb = mid, fm
        else:
            a, fa = mid, fm
    return mid


def f_poly(x):
    return 3 * x**2 - 5


root1 = bisection(math.atan, -0.5, 0.6, tol=1e-8)
root2 = bisection(math.atan, -1.5, -0.4, tol=1e-8)
root3 = bisection(f_poly, -0.5, 0.6, tol=1e-8)
root4 = bisection(f_poly, -1.5, -0.4, tol=1e-8)

print("Roots for atan in [-0.5, 0.6]:", root1)
print("Roots for atan in [-1.5, -0.4]:", root2)
print("Roots for 3x^2 - 5 in [-0.5, 0.6]:", root3)
print("Roots for 3x^2 - 5 in [-1.5, -0.4]:", root4)
```
