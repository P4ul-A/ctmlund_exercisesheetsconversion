---
title: "Sheet Four"
format: html
filters:
  - pyodide
---

NUMA01: Computational Programming with Python  
Malin Christersson, Robert Klöfkorn  

The purpose of this training assignment is to experiment more with plotting and functions.  
This assignment has 6 tasks.

Solutions: [Sheet 4 Solutions](sheet_4_solutions.qmd)

## Warming-up Exercises

### Task 1

Implement the following code.

```{pyodide-python}
#| read-only: false
from numpy import *
import matplotlib.pyplot as plt

x = linspace(0, 2*pi, 1000)
f_x = cos(x)
f_y = sin(x)

# use subplots to create a individual figures, using plt. creates global figures
# which can lead to problems when creating multiple plots (only showing the last one)
fig, ax = plt.subplots()

ax.plot(f_x, f_y)
ax.set_xlabel('cos (x)')
ax.set_ylabel('sin (x)')
plt.show()
```

### Task 2

Read Chapter 6, section *Formatting* to learn how to change the plotting style and add a legend.

```{pyodide-python}
#| read-only: false
# TODO: experiment with plotting styles and legends.
```

---

## Exercises

### Task 3 – Complex valued functions

The complex valued function $f(\varphi, r) = r e^{i \varphi}$ describes a circle with radius $r$ in the complex plane when $r$ is fixed and $\varphi$ varies between $0$ and $2\pi$. Set up a function that evaluates $f$ and plot it for a fixed value of $r$. Note: the real part of a complex variable $z$ is `z.real` and the imaginary part is `z.imag`. The imaginary unit $i$ is written as `1j` in Python.

Then let $r$ vary from 0.1 to 1.0 and plot the corresponding concentric circles. You should see several circles centered at the origin.

```{pyodide-python}
#| read-only: false
# TODO: implement f(phi, r) and plot concentric circles for varying r.
```

### Task 4 – Euler's formula

Study <https://en.wikipedia.org/wiki/Euler%27s_formula> and relate it to Task 3.

### Task 5 – Newton's Method
(For this task you need knowledge from the course book Chapter 7 (Passing
arguments, Return Values), and Chapter 9 (Controlling the flow inside the
loop) 

Newton's method iteratively finds a root of a function $f$ via

$$
 x_{n+1} = x_n - \frac{f(x_n)}{f'(x_n)}.
$$

Start from a value $x_0$ and stop when $|x_{n+1} - x_n| < \text{TOL}$ or after at most 400 iterations.

Write a function `newton` that takes `f`, `fp` (the derivative), `x0` (start value), and `tol` (tolerance). It should return the last value and a flag `conv` indicating whether convergence was observed. Try the method with a function `myfunc` of your choice and its derivative `myfuncp`.

```{pyodide-python}
#| read-only: false
# TODO: implement Newton's method and test it with your own function.
```

### Extra Task 6

Compare the number of iterations needed to find a root within tolerance $1\times 10^{-8}$ for Newton's method and for the bisection method from Exercise 3. Store the values $|x_{n+1} - x_n|$ for each iteration $n$ for both methods and plot iteration number versus $|x_{n+1} - x_n|$. Discuss what you observe.

```{pyodide-python}
#| read-only: false
# TODO: compare Newton vs. bisection iteration errors and plot the results.
```
